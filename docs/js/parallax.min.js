/*!
 * parallax.js v1.5.0 (http://pixelcog.github.io/parallax.js/)
 * @copyright 2016 PixelCog, Inc.
 * @license MIT (https://github.com/pixelcog/parallax.js/blob/master/LICENSE)
 */
(function($, window, document, undefined) {
    // Constructor function for Parallax
    function Parallax(element, options) {
      var self = this;
      
      // Merge options with default values
      if (typeof options === 'object') {
        delete options.refresh;
        delete options.render;
        $.extend(this, options);
      }
      
      this.$element = $(element);
      
      // Set image source if it's not provided
      if (!this.imageSrc && this.$element.is('img')) {
        this.imageSrc = this.$element.attr('src');
      }
      
      // Process position
      var position = (this.position + '').toLowerCase().match(/\S+/g) || [];
      if (position.length < 1) position.push('center');
      if (position.length === 1) position.push(position[0]);
      if (['top', 'bottom'].includes(position[0]) || ['left', 'right'].includes(position[1])) {
        position = [position[1], position[0]];
      }
      
      this.positionX = this.positionX !== undefined ? this.positionX.toLowerCase() : position[0];
      this.positionY = this.positionY !== undefined ? this.positionY.toLowerCase() : position[1];
      
      this.positionX = ['left', 'right'].includes(this.positionX) ? this.positionX : isNaN(parseInt(this.positionX)) ? 'center' : parseInt(this.positionX);
      this.positionY = ['top', 'bottom'].includes(this.positionY) ? this.positionY : isNaN(parseInt(this.positionY)) ? 'center' : parseInt(this.positionY);
      
      this.position = `${this.positionX}${isNaN(this.positionX) ? '' : 'px'} ${this.positionY}${isNaN(this.positionY) ? '' : 'px'}`;
      
      if (navigator.userAgent.match(/(iPod|iPhone|iPad)/)) {
        if (this.imageSrc && this.iosFix && !this.$element.is('img')) {
          this.$element.css({
            backgroundImage: `url(${this.imageSrc})`,
            backgroundSize: 'cover',
            backgroundPosition: this.position
          });
        }
        return this;
      }
      
      if (navigator.userAgent.match(/(Android)/)) {
        if (this.imageSrc && this.androidFix && !this.$element.is('img')) {
          this.$element.css({
            backgroundImage: `url(${this.imageSrc})`,
            backgroundSize: 'cover',
            backgroundPosition: this.position
          });
        }
        return this;
      }
      
      // Create mirror element
      this.$mirror = $('<div />').prependTo(this.mirrorContainer);
      var $slider = this.$element.find('>.parallax-slider');
      var isNew = $slider.length === 0;
      
      if (isNew) {
        this.$slider = $('<img />').prependTo(this.$mirror);
      } else {
        this.$slider = $slider.prependTo(this.$mirror);
      }
      
      this.$mirror.addClass('parallax-mirror').css({
        visibility: 'hidden',
        zIndex: this.zIndex,
        position: 'fixed',
        top: 0,
        left: 0,
        overflow: 'hidden'
      });
      
      this.$slider.addClass('parallax-slider').one('load', function() {
        if (!self.naturalHeight || !self.naturalWidth) {
          self.naturalHeight = this.naturalHeight || this.height || 1;
          self.naturalWidth = this.naturalWidth || this.width || 1;
          self.aspectRatio = self.naturalWidth / self.naturalHeight;
          if (!Parallax.isSetup) Parallax.setup();
          Parallax.sliders.push(self);
          Parallax.isFresh = false;
          Parallax.requestRender();
        }
      });
      
      if (!isNew) {
        this.$slider[0].src = this.imageSrc;
      }
      
      if (this.naturalHeight && this.naturalWidth || this.$slider[0].complete || $slider.length > 0) {
        this.$slider.trigger('load');
      }
    }
  
    // Polyfill for requestAnimationFrame
    (function() {
      var lastTime = 0;
      var vendors = ['ms', 'moz', 'webkit', 'o'];
      for (var i = 0; i < vendors.length && !window.requestAnimationFrame; i++) {
        window.requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
      }
      
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback) {
          var now = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (now - lastTime));
          var id = window.setTimeout(function() { callback(now + timeToCall); }, timeToCall);
          lastTime = now + timeToCall;
          return id;
        };
      }
      
      if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      }
    })();
  
    // Parallax prototype methods
    $.extend(Parallax.prototype, {
      speed: 0.2,
      bleed: 0,
      zIndex: -100,
      iosFix: true,
      androidFix: true,
      position: 'center',
      overScrollFix: false,
      mirrorContainer: 'body',
  
      refresh: function() {
        this.boxWidth = this.$element.outerWidth();
        this.boxHeight = this.$element.outerHeight() + 2 * this.bleed;
        this.boxOffsetTop = this.$element.offset().top - this.bleed;
        this.boxOffsetLeft = this.$element.offset().left;
        this.boxOffsetBottom = this.boxOffsetTop + this.boxHeight;
  
        var windowHeight = Parallax.winHeight;
        var documentHeight = Parallax.docHeight;
        var top = Math.min(this.boxOffsetTop, documentHeight - windowHeight);
        var bottom = Math.max(this.boxOffsetTop + this.boxHeight - windowHeight, 0);
        var height = this.boxHeight + (top - bottom) * (1 - this.speed) | 0;
        var offsetTop = (this.boxOffsetTop - top) * (1 - this.speed) | 0;
  
        if (height * this.aspectRatio >= this.boxWidth) {
          this.imageWidth = height * this.aspectRatio | 0;
          this.imageHeight = height;
          this.offsetBaseTop = offsetTop;
          var offsetLeft = this.imageWidth - this.boxWidth;
  
          if (this.positionX === 'left') {
            this.offsetLeft = 0;
          } else if (this.positionX === 'right') {
            this.offsetLeft = -offsetLeft;
          } else if (isNaN(this.positionX)) {
            this.offsetLeft = -offsetLeft / 2 | 0;
          } else {
            this.offsetLeft = Math.max(this.positionX, -offsetLeft);
          }
        } else {
          this.imageWidth = this.boxWidth;
          this.imageHeight = this.boxWidth / this.aspectRatio | 0;
          this.offsetLeft = 0;
          var offsetBottom = this.imageHeight - height;
  
          if (this.positionY === 'top') {
            this.offsetBaseTop = offsetTop;
          } else if (this.positionY === 'bottom') {
            this.offsetBaseTop = offsetTop - offsetBottom;
          } else if (isNaN(this.positionY)) {
            this.offsetBaseTop = offsetTop - offsetBottom / 2 | 0;
          } else {
            this.offsetBaseTop = offsetTop + Math.max(this.positionY, -offsetBottom);
          }
        }
      },
  
      render: function() {
        var scrollTop = Parallax.scrollTop;
        var scrollLeft = Parallax.scrollLeft;
        var overScroll = this.overScrollFix ? Parallax.overScroll : 0;
        var viewportBottom = scrollTop + Parallax.winHeight;
  
        if (this.boxOffsetBottom > scrollTop && this.boxOffsetTop <= viewportBottom) {
          this.visibility = 'visible';
          this.mirrorTop = this.boxOffsetTop - scrollTop;
          this.mirrorLeft = this.boxOffsetLeft - scrollLeft;
          this.offsetTop = this.offsetBaseTop - this.mirrorTop * (1 - this.speed);
        } else {
          this.visibility = 'hidden';
        }
  
        this.$mirror.css({
          transform: `translate3d(${this.mirrorLeft}px, ${this.mirrorTop - overScroll}px, 0px)`,
          visibility: this.visibility,
          height: this.boxHeight,
          width: this.boxWidth
        });
  
        this.$slider.css({
          transform: `translate3d(${this.offsetLeft}px, ${this.offsetTop}px, 0px)`,
          position: 'absolute',
          height: this.imageHeight,
          width: this.imageWidth,
          maxWidth: 'none'
        });
      }
    });
  
    // Static properties and methods
    $.extend(Parallax, {
      scrollTop: 0,
      scrollLeft: 0,
      winHeight: 0,
      winWidth: 0,
      docHeight: 1 << 30,
      docWidth: 1 << 30,
      sliders: [],
      isReady: false,
      isFresh: false,
      isBusy: false,
  
      setup: function() {
        function update() {
          if (lastScrollTop === window.pageYOffset) {
            window.requestAnimationFrame(update);
            return false;
          }
          lastScrollTop = window.pageYOffset;
          instance.render();
          window.requestAnimationFrame(update);
        }
  
        if (!this.isReady) {
          var instance = this;
          var $document = $(document);
          var $window = $(window);
  
          function updateDimensions() {
            Parallax.winHeight = $window.height();
            Parallax.winWidth = $window.width();
            Parallax.docHeight = $document.height();
            Parallax.docWidth = $document.width();
          }
  
          function updateScroll() {
            var scrollTop = $window.scrollTop();
            var docHeight = Parallax.docHeight;
            var winHeight = Parallax.winHeight;
            var docWidth = Parallax.docWidth;
            var winWidth = Parallax.winWidth;
  
            Parallax.scrollTop = Math.max(0, Math.min(docHeight - winHeight, scrollTop));
            Parallax.scrollLeft = Math.max(0, Math.min(docWidth - winWidth, $window.scrollLeft()));
            Parallax.overScroll = Math.max(scrollTop - (docHeight - winHeight), Math.min(scrollTop, 0));
          }
  
          $window.on('resize.px.parallax load.px.parallax', function() {
            updateDimensions();
            instance.refresh();
            Parallax.isFresh = false;
            Parallax.requestRender();
          }).on('scroll.px.parallax load.px.parallax', function() {
            updateScroll();
            Parallax.requestRender();
          });
  
          updateDimensions();
          updateScroll();
          this.isReady = true;
  
          var lastScrollTop = -1;
          update();
        }
      },
  
      configure: function(options) {
        if (typeof options === 'object') {
          delete options.refresh;
          delete options.render;
          $.extend(this.prototype, options);
        }
      },
  
      refresh: function() {
        $.each(this.sliders, function() {
          this.refresh();
        });
        this.isFresh = true;
      },
  
      render: function() {
        if (!this.isFresh) {
          this.refresh();
        }
        $.each(this.sliders, function() {
          this.render();
        });
      },
  
      requestRender: function() {
        var self = this;
        this.render();
        this.isBusy = false;
      },
  
      destroy: function(element) {
        var $element = $(element).data('px.parallax');
        $element.$mirror.remove();
  
        var index = $.inArray($element, this.sliders);
        if (index !== -1) {
          this.sliders.splice(index, 1);
        }
  
        $(element).data('px.parallax', false);
  
        if (this.sliders.length === 0) {
          $(window).off('scroll.px.parallax resize.px.parallax load.px.parallax');
          this.isReady = false;
          Parallax.isSetup = false;
        }
      }
    });
  
    // jQuery plugin definition
    var old = $.fn.parallax;
    $.fn.parallax = function(options) {
      return this.each(function() {
        var $this = $(this);
        var data = $this.data('px.parallax');
        var opts = typeof options === 'object' && options;
  
        if (this === window || this === document || $this.is('body')) {
          Parallax.configure(opts);
        } else if (data) {
          if (typeof options === 'object') {
            $.extend(data, opts);
          }
        } else {
          opts = $.extend({}, $this.data(), opts);
          $this.data('px.parallax', new Parallax(this, opts));
        }
  
        if (typeof options === 'string') {
          if (options === 'destroy') {
            Parallax.destroy(this);
          } else {
            Parallax[options]();
          }
        }
      });
    };
  
    $.fn.parallax.Constructor = Parallax;
    $.fn.parallax.noConflict = function() {
      $.fn.parallax = old;
      return this;
    };
  
    // Initialize parallax elements
    $(function() {
      $('[data-parallax="scroll"]').parallax();
    });
  
  })(jQuery, window, document);